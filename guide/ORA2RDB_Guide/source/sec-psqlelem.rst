.. _sec:psqlelem:

Преобразование элементов процедурного языка PL/SQL
===================================================

Исключения (``EXCEPTION``)
----------------------------

.. _sub:declare_exception:

Объявление пользовательского исключения
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

В Oracle существуют два вида исключений:

- системные исключения, объявленные в пакете ``STANDARD``. 
- пользовательские исключения, которые явно объявляются в анонимном блоке, процедуре, функции, триггере или пакете.

Рассмотрим синтаксис объявления пользовательских исключений в процедуре. Для функции всё аналогично. 
В анонимных блоках и триггерах исключения объявляются в разделе ``DECLARE``.

.. code-block::
    :emphasize-lines: 4,7,8,9
    :greenlines: 1,2,3,4,5,6,7,8,9,10
    :caption: Oracle
    
    CREATE [ OR REPLACE ] PROCEDURE [ <схема>. ] <имя процедуры>
       [ ( <IN|OUT параметр> [, <IN|OUT параметр>]... ) ] 
    { IS | AS } [<объявление>;...] 
            <имя исключения> EXCEPTION;            
    BEGIN 
        <блок операторов> ... 
        RAISE <имя исключения>;
        EXCEPTION
           WHEN <имя исключения> THEN [<обработка исключения>]
    END [<имя процедуры>] ;


Инициирование исключений
^^^^^^^^^^^^^^^^^^^^^^^^^^

Исключение может быть инициировано в подпрограмме Oracle тремя способами:

- при обнаружении ошибки;
- командой ``RAISE``;
- встроенной процедурой ``RAISE_APPLICATION_ERROR``.


Команда RAISE
""""""""""""""

Чтобы разработчик имел возможность самостоятельно инициировать именованные исключения, в Oracle 
поддерживается команда RAISE. С ее помощью можно инициировать как собственные, так и системные исключения. 
Команда имеет три формы:

.. code-block::

    RAISE имя_исключения;
    RAISE имя_пакета.имя_исключения;
    RAISE;

Первая форма (без имени пакета) может инициировать исключения, определенные в текущем блоке 
(или в содержащем его блоке), а также системные исключения.

Если исключение объявлено в пакете (но не в ``STANDARD``) и инициируется извне, имя исключения необходимо уточнить именем пакета.

Третья форма ``RAISE`` не требует указывать имя исключения, но используется только в условии ``WHEN`` обработчика исключений. 
Эта форма используется для повторного инициирования (передачи) перехваченного исключения.


Процедура RAISE_APPLICATION_ERROR
"""""""""""""""""""""""""""""""""""

Для инициирования исключений Oracle предоставляет процедуру ``RAISE_APPLICATION_ERROR``. 
Ее преимущество перед командой ``RAISE`` заключается в том, что она позволяет связать с исключением сообщение об ошибке.


Обработка исключений (Exception Handler)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2,3,4,5,6,7,8,9
             
             EXCEPTION
               WHEN {<имя искл-я> [OR <имя искл-я>]... 
                    | OTHERS }
               THEN 
                  <оператор>; [ <оператор>; ]...

               [WHEN { <имя искл-я> [ OR <имя искл-я> ]... 
                    | OTHERS }
                THEN <оператор>; [<оператор>;]...]
             
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2,3,4,5,6,7,8,9
              
                                                        .
             WHEN {<имя искл-я> [, <имя искл-я> ...] 
                  | ANY}
             DO [BEGIN] 
                  <оператор>; [ <оператор>; ]...
             [END]
             [WHEN {<имя искл-я> [, <имя искл-я>...] 
                   | ANY}
              DO [BEGIN] <оператор>;[<оператор>;]...[END]]
  	 

.. _subsec:decl:

Блок объявлений
-------------------------


В процедурах, функциях, триггерах, пакетах или анонимных PSQL-блоках есть возможность 
объявлять необходимые элементы языка (переменные, курсоры, подпрограммы и т.д.).

Для примера представим синтаксис создания процедуры с блоком объявлений. 
Для остальных объектов синтаксис аналогичен:


.. color-block::
    :caption: Oracle
    
    :green:`CREATE [OR REPLACE]` :red:`[EDITIONABLE|NONEDITIONABLE]` :green:`PROCEDURE` :red:`[<схема>.]` :green:`<имя процедуры>`
        :green:`[ ( <IN|OUT параметр> [, <IN|OUT параметр>]... ) ]` 
        :green:`...`
    :green:`{ IS | AS } [` :greenbf:`<блок объявлений>` :green:`]`
    :green:`BEGIN`
        :green:`<блок операторов> ...`
    :green:`END` :red:`[<имя процедуры>]` :green:`;`    
    
    :greenbf:`<блок объявлений>` :green:`::=  { {<объявление_1>;... [<объявление_2>;]...}`
                           :green:`| <объявление_2>;...}`

    :green:`<объявление_1> ::= { <объявление типа коллекций>`
                       :green:`| <объявление типа RECORD>`
                       :red:`| <объявление типа REF CURSOR>`
                       :red:`| <объявление типа SUBTYPE>`
                       :green:`| <объявление курсора>`
                       :green:`| <объявление переменных>`
                       :green:`| <объявление функции>`
                       :green:`| <объявление процедуры> }`

    :green:`<объявление_2> ::= { <объявление функции> | <реализация функции>`
                       :green:`| <объявление процедуры> | <реализация процедуры>`
                       :green:`| <объявление курсора> | <задание курсора> }`

.. _subsec:collections:

Объявление типов коллекций
^^^^^^^^^^^^^^^^^^^^^^^^^^^

PL/SQL имеет три типа коллекций:

- Ассоциативный массив (Associative Array)
- Массив переменной длины (Varray)
- Вложенная таблица (Nested table).

Массивы переменной длины и вложенные таблицы не поддерживаются РБД и не могут быть преобразованы конвертером. 

Преобразование объявлений ассоциативных массивов и их переменных
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Синтаксис для объявления типа ассоциативного массива в Oracle:

.. color-block::
    :caption: Oracle
    
    :green:`TYPE <имя типа ассоц.массива>`
    :green:`IS TABLE OF <тип данных> [ NOT NULL ]`
    :green:`INDEX BY { VARCHAR2 (<размер>)`
             :green:`| BINARY_INTEGER`
             :green:`| PLS_INTEGER`
             :green:`| LONG`
             :red:`| <имя переменной>%TYPE`
             :red:`| <имя курсора/таблицы/представления>%ROWTYPE` :green:`};`
    
Объявление переменной типа ассоциативного массива в Oracle:

.. color-block::
    :caption: Oracle

    :green:`<имя переменной> <имя типа ассоц.массива>` 
      :red:`[:=<выражение> | :=<вызов функции> | :=<имя переменной коллекции>]`:green:`;`

При конвертации объявления ассоциативного массива выполняются следующие задачи:  

1. *Создание глобальных временных таблиц*
   
   В чистом виде ассоциативные массивы не поддерживаются РБД. Однако, вместо их прямого использования 
   можно создать глобальные временные таблицы (GTT).
   Для каждой переменной ассоциативного массива формируется отдельная GTT, состоящая из двух полей: ключа (``I1``) и значения (``VAL``). 
   При этом поле ``I1`` выполняет роль первичного ключа.
   Тип данных для ключа может быть представлен только в виде ``VARCHAR`` (если ассоциативный массив индексирован строкой) или ``INTEGER``
   (если ассоциативный массив индексирован целым числом). 
   Следует отметить, что атрибуты ``%TYPE`` и ``%ROWTYPE`` не поддерживаются в РБД.

   .. code-block:: 
    :greenlines: 1,2,3,4,5,6
    :caption: Rdb
    
    CREATE GLOBAL TEMPORARY TABLE <имя переменной> (
       I1 { VARCHAR(<размер>)
          | INTEGER },
       VAL <тип данных> [NOT NULL],
       CONSTRAINT <имя ограничения> PRIMARY KEY (I1)
    );
  
2. Объявление ассоциативного массива и объявление переменной типа ассоциативного массива *комментируются*. 

Также при конвертации выполняется преобразование следующих операций в теле PL/SQL блока:

- *Заполнение переменной типа ассоциативного массива значениями*

  Поскольку вместо ассоциативного массива будет создана глобальная временная таблица (GTT), 
  операции присваивания значений переменной типа ассоциативного массива будут заменены на 
  вставку или обновление данных в эту GTT таблицу. Например: 
  
  .. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block:: sql
             
             city_population('Мегаполис') := 1000000;
                                                    .
             
        - :ess:`toRdb`
        
          .. code-block:: sql
             
             UPDATE OR INSERT INTO CITY_POPULATION VALUES ('Мегаполис', 1000000);
  
- *Обращение по ключу*

  Поскольку вместо ассоциативного массива будет создана глобальная временная таблица (GTT), 
  обращение по ключу к элементам ассоциативного массива будет заменено на операцию ``SELECT``. Например:

  .. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block:: sql
             
             l_res := city_population('Деревня');
                                                    .
             
        - :ess:`toRdb`
        
          .. code-block:: sql
             
             l_res = (SELECT VAL FROM CITY_POPULATION WHERE I1 = 'Деревня');


Приведем пример конвертации функции с объявлением ассоциативного массива.

.. code-block:: sql
    :caption: Oracle
  
    CREATE OR REPLACE FUNCTION TEST_FUNCTION
    RETURN NUMERIC(34, 8)
    IS
      TYPE population IS TABLE OF NUMBER INDEX BY VARCHAR2(64);      
      city_population population; 
      l_res NUMERIC(34, 8);
    BEGIN
      city_population('Деревня')   := 2000;
      city_population('Райцентр')  := 750000;
      city_population('Мегаполис') := 1000000;
      city_population('Деревня')  := 2001;
      l_res := city_population('Деревня')+city_population('Райцентр')+city_population('Мегаполис');
      ... 
      return l_res;
    END TEST_FUNCTION;

.. code-block:: sql
    :caption: to Rdb
  
    CREATE GLOBAL TEMPORARY TABLE CITY_POPULATION (
        I1 VARCHAR(64), 
        VAL NUMERIC(34, 8),
        CONSTRAINT PK_CITY_POPULATION PRIMARY KEY (I1)
    );
    
    CREATE OR ALTER FUNCTION TEST_FUNCTION 
    RETURNS NUMERIC(34, 8)
    AS
      /*TYPE population IS TABLE OF NUMERIC(34, 8) INDEX BY VARCHAR(64);*/
      /*city_population  population;*/
      DECLARE l_res NUMERIC(34, 8);
    BEGIN
      UPDATE OR INSERT INTO CITY_POPULATION VALUES ('Деревня', 2000);
      UPDATE OR INSERT INTO CITY_POPULATION VALUES ('Райцентр', 750000);
      UPDATE OR INSERT INTO CITY_POPULATION VALUES ('Мегаполис', 1000000);
      UPDATE OR INSERT INTO CITY_POPULATION VALUES ('Деревня', 2001);
      l_res = (SELECT VAL FROM CITY_POPULATION WHERE I1 = 'Деревня')
              + (SELECT VAL FROM CITY_POPULATION WHERE I1 = 'Райцентр')
              + (SELECT VAL FROM CITY_POPULATION WHERE I1 = 'Мегаполис');
      ...
      return l_res;
    END /*TEST_FUNCTION*/;



Объявление типа RECORD
^^^^^^^^^^^^^^^^^^^^^^^

Сравнение синтаксиса объявления типа Record:

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. color-block::
              
              :green:`TYPE <имя типа Record>`
              :green:`IS RECORD (<имя поля> <тип данных>` 
                         :green:`[[NOT NULL]`
                         :green:`{:=|DEFAULT} <выражение>]`
                         :green:`[, <имя поля> <тип данных>...]);`

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5
             
             DECLARE TYPE <имя типа Record> 
             (<имя поля> <тип данных>
              [DEFAULT <значение>]
              [NOT NULL]
              [, <имя поля> <тип данных>...]...);

При конвертации выполняются следующие задачи:  

1. *Добавление ключевого слова* ``DECLARE``

   В РБД объявление любого элемента (в том числе типа) начинается с ключевого слова ``DECLARE``.
   Оно добавляется перед ключевым словом ``TYPE``.

2. *Удаление ключевых слов* ``IS RECORD``

3. *Замена операции присваивания* 
   
   В РБД значение по умолчанию устанавливается с использованием ключевого слова ``DEFAULT``. Таким образом, знак присваивания ``:=`` 
   заменяется на ``DEFAULT``.

4. *Изменение в порядке ключевых слов*
   
   Если задано ограничение ``NOT NULL`` и значение по умолчанию, то при конвертации меняется порядок их задания.


.. code-block:: sql
    :caption: Oracle
  
    DECLARE
      TYPE DeptRecTyp IS RECORD (
         dept_id    NUMBER(4) NOT NULL := 10,
         dept_name  VARCHAR2(30) NOT NULL := 'Administration',
         mgr_id     NUMBER(6) := 200,
         loc_id     NUMBER(4) := 1700
      ); 
      dept_rec DeptRecTyp;
    BEGIN
       ...
    END;



.. code-block:: sql
    :caption: to Rdb
  
    EXECUTE BLOCK
    AS 
      DECLARE TYPE DeptRecTyp (
        dept_id    NUMERIC(4)  default 10 NOT NULL,
        dept_name  VARCHAR(30) default 'Administration' NOT NULL,
        mgr_id     NUMERIC(6)  default 200,
        loc_id     NUMERIC(4)  default 1700
      );
      DECLARE dept_rec DeptRecTyp;
    BEGIN
      ...
    END;



Объявление курсоров
^^^^^^^^^^^^^^^^^^^^^^

Синтаксис для объявления курсора в Oracle:
          
.. color-block::
    :caption: Oracle
    
    :red:`CURSOR <имя курсора>` :red:`[(<список параметров курсора>)]`
    :red:`RETURN <rowtype>;`

В РБД курсоры не требуют предварительного объявления; они задаются непосредственно с помощью оператора ``SELECT``. 
Таким образом, при конвертации строки с объявлением курсоров исключается, а конвертируется непосредственно задание курсора. 

Задание курсоров
^^^^^^^^^^^^^^^^^^^^^

Синтаксис для задания курсора в Oracle:

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,4
             :redlines: 2,3
              
             CURSOR <имя курсора>
             [(<список параметров курсора>)]
             [RETURN <rowtype>] 
             IS <SELECT-запрос> ;

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,4

             DECLARE <имя курсора>  


             CURSOR FOR (<SELECT-запрос>);

При конвертации выполняются следующие задачи:  

1. *Комментирование курсора с входными параметрами*
   
   В РБД не поддерживатся курсоры с входными параметрами. Поэтому при конвертации такие курсоры комментируются.

2. *Удаление конструкции* ``RETURN``

   В РБД конструкция ``RETURN`` отсутствует. Но её удаление никак не сказывается на работу курсора.

3. *Добавление ключевого слова* ``DECLARE``

   В РБД объявление любого элемента начинается с ключевого слова ``DECLARE``.
   
4. *Удаление ключевого слова* ``CURSOR``

5. Замена ключевого слова ``IS`` на ключевые слова ``CURSOR FOR``

6. *SELECT-запрос оборачивается в скобки*.
 


.. code-block:: sql
  :caption: Oracle

  DECLARE
    id testt.id%TYPE;
    num testt.num%TYPE;
    cursor c1 RETURN testt%ROWTYPE;
    cursor c1 RETURN testt%ROWTYPE is
      SELECT * FROM testt;
  BEGIN
    OPEN c1;
    LOOP
      FETCH c1 INTO id, num;
      EXIT WHEN c1%NOTFOUND;
    END LOOP;
    CLOSE c1;
  END;


.. code-block:: sql
  :caption: to Rdb

  EXECUTE BLOCK 
  AS
    DECLARE id TYPE OF COLUMN testt.id;
    DECLARE num TYPE OF COLUMN testt.num;
    DECLARE c1 CURSOR FOR
      (SELECT * FROM testt);
  BEGIN
    OPEN c1;
    WHILE (TRUE) DO 
    BEGIN
      FETCH c1 INTO :id, :num;
        IF( ROW_COUNT != 1 ) 
        THEN LEAVE;
    END 
    CLOSE c1;
  END;

Операторы для работы с курсорами и их преобразование описаны в следующем подразделе.


Объявление переменных
^^^^^^^^^^^^^^^^^^^^^^

В PL/SQL блоках можно объявлять различные переменные, каждая из которых конвертируется по своему. 
Ниже перечислены основные типы переменных, которые можно использовать в блоке объявления:

.. code-block::
    :redlines:  2,3
    :greenlines: 1,4,5,6,7
    :caption: Oracle

    { <объявление переменных типа коллекций>
    | <объявление констант>
    | <объявление переменной типа REF CURSOR>
    | <объявление исключений>
    | <объявление переменной типа RECORD>
    | <объявление скалярной переменной>
    }

Далее рассмотрим синтаксис объявления каждой из них.

Объявление переменных типа коллекций
""""""""""""""""""""""""""""""""""""""

Перед объявлением переменной типа коллекции, сам тип должен быть ранее определен в том же блоке. 


.. code-block::
    :redlines:  2,3,4,5,6,7
    :greenlines: 1
    :caption: Oracle
        
    <имя переменной> { <имя типа ассоц.массива> 
                       [:=<выражение> | :=<вызов функции> | :=<имя переменной коллекции>]
                     | <имя типа Varray> 
                       [:= <имя типа Varray>([<список значений>]) | :=<имя переменной коллекции> ]
                     | <имя типа вложенных таблиц> 
                       [:= <имя вложенных таблиц>([<список значений>]) | :=<имя переменной коллекции>]
                     | <имя переменной коллекции>%TYPE } ;    

Объявление типов коллекций было подробно рассмотрено в :numref:`подразделе %s<subsec:collections>`. 
В этом разделе отмечается, что в РБД аналогичные коллекции не поддерживаются, и что конвертер способен 
преобразовать только ассоциативные массивы (в GTT таблицы). Кроме того, в этом же разделе уже описано преобразование
объявления переменной ассоциативного массива. Поэтому в этом пункте задачи преобразования рассматриваться не будут.  

Объявление констант
"""""""""""""""""""""
        
.. code-block::
    :redlines: 1
    
    <имя константы> CONSTANT <тип данных> [NOT NULL] { := | DEFAULT } <выражение> ;


Объявление исключений
""""""""""""""""""""""

См. :numref:`подраздел %s <sub:declare_exception>`.



Объявление переменной типа RECORD
"""""""""""""""""""""""""""""""""""

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :redlines: 4
             :greenlines: 1,2,3,5,6,7
              
             <имя переменной> 
                    { <имя типа RECORD> 
                    | <имя курсора>%ROWTYPE 
                    | <имя переменной CURSOR REF>%ROWTYPE 
                    | <имя таблицы>%ROWTYPE 
                    | <имя представления>%ROWTYPE 
                    | <имя переменной типа RECORD>%TYPE };


        - :ess:`Rdb`    
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7

             DECLARE [VARIABLE] <имя переменной> 
                   { <имя типа RECORD> 
                   | TYPE OF TABLE  <имя курсора>

                   | TYPE OF TABLE <имя таблицы> 
                   | TYPE OF TABLE <имя представления>
                   | <имя типа RECORD> };


Объявление скалярной переменной
""""""""""""""""""""""""""""""""

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1, 2, 3, 4
              
                                                   .
             <имя переменной> <тип данных> 
             [[NOT NULL] 
             {:= | DEFAULT} <выражение> ] ;

        - :ess:`Rdb`    
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4

             DECLARE [VARIABLE] 
             <имя переменной> <тип данных>
             [NOT NULL] 
             [{ = | DEFAULT } <значение по умолчанию>] ;

.. _subsec:proc_decl:

Объявление процедуры
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block::
    :redlines:  2,3
    :greenlines: 1,4
    :caption: Oracle
        
    PROCEDURE <процедура> [(<IN|OUT параметр>[,<IN|OUT параметр>])] 
    [ ACCESSIBLE BY (<средство доступа> [, <средство доступа> ]...)
    | DEFAULT COLLATION <опция сортировки>
    | AUTHID { CURRENT_USER | DEFINER }]... ;

Преобразование объявления пакетной процедуры без OUT-параметров
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Сравнение операторов создания пакета с объявлением пакетных процедур без параметров или только с IN-параметрами:

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
              :greenlines: 1, 2, 3, 4, 5, 7, 8, 9
              
              CREATE [OR REPLACE] PACKAGE <имя пакета>
              [AUTHID { CURRENT_USER | DEFINER }]
              { IS | AS } 
                 PROCEDURE <имя> (<IN-пар.>[,<IN-пар.>]); 

                 [ <объявление процедуры>; 
                 | <объявление функции>;...]
              END ;

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 7, 8, 9
             
             CREATE [OR ALTER] PACKAGE <имя пакета>
             [SQL SECURITY {DEFINER | INVOKER}]
             AS BEGIN
                PROCEDURE <имя> (<IN-пар.>[,<IN-пар.>]);

                [ <объявление процедуры>; 
                | <объявление функции>;...]
             END ; 

При конвертации объявления пакетных процедур без OUT-параметров выполняются следующие задачи:  

1. *Преобразование IN-параметров* 

   В Oracle входные параметры могут прописываться с модификатором ``IN`` (необязательным). 
   При конвертации модификатор ``IN`` удаляется.

   Сравним синтаксис задания IN-параметров [2]_:

   .. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
      
          .. color-block::
             
             :green:`<IN-параметр> :=` 
                        :green:`<имя>` :red:`[IN]` :green:`<тип данных>` 
                             :green:`[{:=|DEFAULT} <значение>]`                  
  	                                                        
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3
             
             <IN-параметр> := 
                       <имя> <тип данных> 
                            [{=|DEFAULT} <значение>]     

   IN-параметрам можно устанавливать значения по умолчанию. Как видно, различия заключаются лишь в операторе присваивания (``:=``). 
   
   .. note::

      В РБД параметры, для которых установлены значения по умолчанию, должны располагаться в самом конце списка, 
      тогда как в Oracle таких ограничений нет.

Преобразование объявления пакетной процедуры с OUT параметрами
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Сравнение операторов создания пакета с объявлением пакетных процедур с хотя бы одним OUT-параметром:

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
              :greenlines: 1, 2, 3, 4, 5, 8, 9, 10
              
              CREATE [OR REPLACE] PACKAGE <имя пакета>
              [AUTHID { CURRENT_USER | DEFINER }]
              { IS | AS } 
              PROCEDURE <имя> (<OUT-пар.>[,<IN|OUT-пар.>]); 


              [ <объявление процедуры>; 
              | <объявление функции>;...];
              END ;

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 8, 9, 10
             
             CREATE [OR ALTER] PACKAGE <имя пакета>
             [SQL SECURITY {DEFINER | INVOKER}]
             AS BEGIN
             PROCEDURE <имя> (<OUT-пар.>[,<IN|OUT-пар.>])
             RETURNS (<OUT-пар.>_OUT [,...]);

             [ <объявление процедуры>; 
             | <объявление функции>;...]
             END ; 


При конвертации объявления пакетных процедур с OUT-параметрами выполняются следующие задачи:  

1. *Преобразование входных параметров*

   В процедурах Oracle все параметры являются входными, однако они подразделяются на IN и OUT. 

   Модификаторы ``IN, OUT`` и ``IN OUT`` не используются и удаляются. Следует отметить, что в РБД отсутствует аналог модификатора ``NOCOPY``, 
   который также подлежит исключению.

   Если в процедуре присутствует хотя бы один OUT-параметр, она преобразуется в селективную процедуру в РБД.  
   Поэтому добавляется конструкция ``RETURNS (...)``, в которую дублируется список всех OUT-параметров с суффиксом ``"_OUT"``.

.. _subsec:func_decl:

Объявление функции 
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block::
    :redlines:  4,5,6 
    :greenlines: 1,2,3
    :caption: Oracle
    
    FUNCTION <имя функции> [(<IN|OUT параметр>[,<IN|OUT параметр>])]
    RETURN <тип данных> 
    [ DETERMINISTIC 
    | PIPELINED 
    | PARALLEL_ENABLE 
    | RESULT_CACHE ]... ; 

Преобразование объявления пакетной функции без OUT-параметров
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Сравнение синтаксиса операторов создания пакета с объявлением пакетных функций без параметров или только с IN-параметрами:

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
              :greenlines: 1, 2, 3, 4, 5, 6, 7, 9, 10, 11
              
              CREATE [OR REPLACE] PACKAGE <имя пакета>
              [AUTHID { CURRENT_USER | DEFINER }]
              { IS | AS } 
                 FUNCTION <имя> (<IN-пар.>[,<IN-пар.>]...)
                   RETURN <тип данных> 
                   [DETERMINISTIC];

                 [ <объявление процедуры>; 
                 | <объявление функции>;...];
              END;

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 9, 10, 11
             
             CREATE [OR ALTER] PACKAGE <имя пакета>
             [SQL SECURITY {DEFINER | INVOKER}]
             AS BEGIN
                FUNCTION <имя> (<IN-пар.> [,<IN-пар.>...])
                  RETURNS <тип данных> 
                  [DETERMINISTIC];

                [ <объявление процедуры>; 
                | <объявление функции>;...]
             END ; 

При конвертации объявления пакетных функций без OUT-параметров выполняются следующие задачи:  

1. *Преобразование IN-параметров*

   В Oracle входные параметры могут прописываться с модификатором ``IN`` (необязательным). 
   При конвертации модификатор ``IN`` удаляется.

   Сравним синтаксис задания IN-параметров [4]_:

   .. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
      
          .. color-block::
             
             :green:`<IN-параметр> :=` 
                        :green:`<имя>` :red:`[IN]` :green:`<тип данных>` 
                             :green:`[{:=|DEFAULT} <значение>]`                  
  	                                                        
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3
             
             <IN-параметр> := 
                       <имя> <тип данных> 
                            [{=|DEFAULT} <значение>]     

   IN-параметрам можно устанавливать значения по умолчанию. Как видно, различия заключаются лишь в операторе присваивания (``:=``). 
   В РБД параметры, для которых установлены значения по умолчанию, должны располагаться в самом конце списка, 
   тогда как в Oracle таких ограничений нет.

2. *Замена ключевого слова* ``RETURN``

   Данное ключевое слово заменяется на равнозначное ему ``RETURNS``.


Преобразование объявления пакетной функции с OUT параметрами
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Сравнение синтаксиса операторов создания пакета с объявлением пакетных функций 
с хотя бы одним OUT-параметром:

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
              :redlines: 6
              :greenlines: 1, 2, 3, 4, 5, 7, 8, 9, 10
              
              CREATE [OR REPLACE] PACKAGE <имя пакета>
              [AUTHID { CURRENT_USER | DEFINER }]
              { IS | AS } 
              FUNCTION <имя> (<OUT-пар.>[,<IN|OUT-пар.>])
              RETURN <тип возвр.данных> 
              [DETERMINISTIC];

              [ <объявление процедуры>; 
              | <объявление функции>;...];
              END ;

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 9, 10, 11
             
             CREATE [OR ALTER] PACKAGE <имя пакета>
             [SQL SECURITY {DEFINER | INVOKER}]
             AS BEGIN
             PROCEDURE <имя> (<OUT-пар.>[,<IN|OUT-пар.>]);
             RETURNS (RET_VAL <тип возвр.знач.>,
                      <OUT-параметр>_OUT [,...])

             [ <объявление процедуры>; 
             | <объявление функции>;...]
             END ; 

При конвертации объявления пакетных функций с OUT параметрами выполняются следующие задачи:  

1. *Преобразование функции в селективную процедуру*
   
   Если в функции присутствует хотя бы один OUT-параметр, она преобразуется в селективную процедуру в РБД. 
   Для этого выполняются следующие действия:
   
   .. unindented_list::
      
      - ключевое слово ``FUNCTION`` заменяется на ключевое слово ``PROCEDURE``.
      - предложение ``RETURN <тип возвращаемого значения>`` заменяется конструкцией
        ``RETURNS`` со списком выходных параметров:

        - добавляется параметр ``RET_VAL``, который принимает тип возвращаемого значения;
        - дублируется список всех OUT-параметров с добавлением суффикса ``"_OUT"``.

2. *Преобразование входных параметров*

   В процедурах Oracle все параметры являются входными, однако они подразделяются на IN и OUT. 

   Модификаторы ``IN, OUT`` и ``IN OUT`` не используются и удаляются. Следует отметить, что в РБД отсутствует аналог модификатора ``NOCOPY``, 
   который также подлежит исключению.


.. _subsec:proc_defin:

Реализация процедуры
^^^^^^^^^^^^^^^^^^^^^^

.. code-block::
    :redlines:  2,3,5
    :greenlines: 1,4,6,7,8,9,10,11
    :caption: Oracle

    PROCEDURE <процедура> [(<IN|OUT параметр>[,<IN|OUT параметр>])] 
    [ ACCESSIBLE BY (<средство доступа> [, <средство доступа> ]...)
    | DEFAULT COLLATION <опция сортировки>
    | AUTHID { CURRENT_USER | DEFINER }]... 
    { { IS | AS } <внешний модуль>
    | { IS | AS } [ <объявление_1>;... [<объявление_2>;]... 
                  | <объявление_2>;... ] 
    BEGIN
        <блок операторов> ...
        [ EXCEPTION <обработка исключений> ]
    END [<имя процедуры>] ; }

Реализация пакетной процедуры с IN параметрами
"""""""""""""""""""""""""""""""""""""""""""""""

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
              :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
              
              CREATE [ OR REPLACE ] 
              PACKAGE BODY [<схема>.] <имя пакета>
              { IS | AS } 
                 PROCEDURE <имя> (<IN-пар.>[,<IN-пар.>])
                 { IS | AS } [<объявление>]
                 BEGIN
                   <блок операторов>
                 END  [<имя процедуры>] ;

                 [ <объявление|реализация процедуры>; 
                 | <объявление|реализация функции>;...];
              END [<имя пакета>] ;

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
             
             RECREATE
             PACKAGE BODY <имя пакета>
             AS BEGIN
                PROCEDURE <имя> (<IN-пар.>[,<IN-пар.>])
                AS [<объявление>]
                BEGIN
                  <блок операторов>
                END ;

                [ <объявление|реализация процедуры>; 
                | <объявление|реализация функции>;...];
             END ; 

Реализация пакетной процедуры с OUT параметрами
"""""""""""""""""""""""""""""""""""""""""""""""

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
              :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
              
              CREATE [ OR REPLACE ] 
              PACKAGE BODY [<схема>.] <имя пакета>
              { IS | AS } 
              PROCEDURE <имя> (<OUT-пар.>[,<IN|OUT-пар.>])

              { IS | AS } [<объявление>]
              BEGIN
                  <блок операторов>
              END  [<имя процедуры>] ;

              [ <объявление|реализация процедуры>; 
              | <объявление|реализация функции>;...];
              END [<имя пакета>] ;

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
             
             RECREATE
             PACKAGE BODY <имя пакета>
             AS BEGIN
             PROCEDURE <имя> (<OUT-пар.>[,<IN|OUT-пар.>])
             RETURNS (<OUT-пар.>_OUT [,...])
             AS [<объявление>]
             BEGIN
                <блок операторов>
             END;

             [ <объявление|реализация процедуры>; 
             | <объявление|реализация функции>;...];
             END ; 


.. _subsec:func_defin:

Реализация функции
^^^^^^^^^^^^^^^^^^^^^^

.. code-block::
    :redlines: 4,5,6,7
    :greenlines: 1,2,3,8,9,10,11,12,13
    :caption: Oracle
    
    FUNCTION <имя функции> [(<IN|OUT параметр>[,<IN|OUT параметр>])]
    RETURN <тип данных> 
    [ DETERMINISTIC
    | PIPELINED
    | PARALLEL_ENABLE
    | RESULT_CACHE [ RELIES_ON ...]  ]...
    { { IS | AS } <внешний модуль>
    | { IS | AS } [ <объявление_1>;... [<объявление_2>;]... 
                  | <объявление_2>;... ] 
    BEGIN
        <блок операторов> ...
        [ EXCEPTION <обработка исключений> ]
    END [<имя процедуры>] ; }


Реализация пакетной функции с IN параметрами
"""""""""""""""""""""""""""""""""""""""""""""

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
              :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14
              
              CREATE [ OR REPLACE ] 
              PACKAGE BODY [<схема>.] <имя пакета>
              { IS | AS } 
                 FUNCTION <имя> (<IN-пар.>[,<IN-пар.>]...)
                   RETURN <тип данных> 
                   [DETERMINISTIC]
                 { IS | AS } [ <объявление> ]
                 BEGIN
                    <блок операторов> ...
                 END [<имя процедуры>] ; 

                 [ <объявление|реализация процедуры>; 
                 | <объявление|реализация функции>;...];
              END [<имя пакета>];

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14
             
             RECREATE
             PACKAGE BODY <имя пакета>
             AS BEGIN
                FUNCTION <имя> (<IN-пар.> [,<IN-пар.>...])
                  RETURNS <тип данных> 
                  [DETERMINISTIC]
                AS [<объявление>]
                BEGIN
                  <блок операторов>
                END ;

                [ <объявление|реализация процедуры>; 
                | <объявление|реализация функции>;...];
             END ; 

Реализация пакетной функции с OUT параметрами
"""""""""""""""""""""""""""""""""""""""""""""


.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
              :redlines: 7
              :greenlines: 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15
              
              CREATE [ OR REPLACE ] 
              PACKAGE BODY [<схема>.] <имя пакета>
              { IS | AS } 
                FUNCTION <имя> (<OUT-пар.>[,<IN|OUT-пар.>])
                RETURN <тип возвр.данных> 

                [DETERMINISTIC]
                { IS | AS } [<объявление>]
                BEGIN
                   <блок операторов>
                END  [<имя процедуры>] ;

                [ <объявление|реализация процедуры>; 
                | <объявление|реализация функции>;...];
              END [<имя пакета>];

        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
             
             RECREATE
             PACKAGE BODY <имя пакета>
             AS BEGIN
              PROCEDURE <имя> (<OUT-пар.>[,<IN|OUT-пар.>])
              RETURNS ( <имя перем.><тип возвр.данных>,
                        <OUT-пар.>_OUT ...)

              AS [<объявление>]
              BEGIN
                 <блок операторов>
              END;

             [ <объявление|реализация процедуры>; 
             | <объявление|реализация функции>;...];
             END ; 




Оператор IF-THEN-ELSE 
------------------------

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2,3,4,5,6,7,8,9,10
             
             IF <условие> 
             THEN <оператор> [ <оператор> ]...
             [ ELSIF <условие> 
               THEN <оператор>[<оператор>]...]

             [ ELSE <оператор> [<оператор>]...] 
             END IF ;
                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2,3,4,5,6,7,8,9,10
             
             IF (<условие>)
             THEN [BEGIN] <оператор>[<оператор>...]
             [IF (<условие>) 
              THEN [BEGIN]<оператор>[<оператор>]...[END]]
             [END]
             [ELSE [BEGIN] <оператор>[<оператор>..][END]];
                                                         .


Оператор WHILE LOOP
---------------------

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2,3
             
             WHILE <выражение>
             LOOP <оператор> [<оператор>...]
             END LOOP [<метка>] ;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2,3
             
             WHILE (<условие>) 
             DO [BEGIN] <оператор> [<оператор>...]
             [END] ;


Оператор FOR LOOP
---------------------

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2,3,4,5
             
             FOR <имя переменной> 
             IN <нижняя граница> .. <верхняя граница>
             LOOP <оператор> [<оператор>...]

             END LOOP [<метка>] ;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2,3,4,5
             
             <имя переменной> = <нижняя граница>;
             WHILE (<имя переменной> <= <верхняя граница>) 
             DO BEGIN <оператор> [<оператор>...]
             <имя переменной> = <имя переменной>+1
             END;


.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2,3,4,5
             
             FOR <имя переменной> 
             IN REVERSE <нижн. граница>..<верх. граница>
             LOOP <оператор> [<оператор>...]

             END LOOP [<метка>] ;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2,3,4,5
             
             <имя переменной> = <верхняя граница>;
             WHILE (<имя переменной> >= <нижняя граница>) 
             DO BEGIN <оператор> [<оператор>...] 
             <имя переменной> = <имя переменной>-1
             END;





Оператор FOR LOOP для оператора SELECT
-----------------------------------------

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2,3,4
             
             FOR <имя переменной типа RECORD> 
             IN (<SELECT-запрос>)
             LOOP <оператор> [<оператор>...] 
             END LOOP [<метка>] ;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2,3,4
             
             FOR <оператор SELECT>
             INTO [:]<имя переменной типа RECORD>
             DO <оператор> [<оператор>...] 
             ;


Оператор LOOP
---------------

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2,3
             
             LOOP 
               <оператор> [<оператор>...]
             END LOOP [<метка>] ;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2,3
             
             WHILE (TRUE)
             DO [BEGIN] <оператор> [<оператор>...]
             [END] ;


Оператор простого CASE
-----------------------

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2,3,4,5
             
             CASE <поисковое выражение>
             WHEN <выражение 1> THEN <результат 1> ;
             [WHEN <выражение 2> THEN <результат 2>;]...
             [ELSE <значение по умолчанию>;]
             END CASE [<<метка>>];

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2,3,4,5
             
             CASE <поисковое выражение>
             WHEN <выражение 1> THEN <результат 1>
             [WHEN <выражение 2> THEN <результат 2>]...
             [ELSE <значение по умолчанию>]
             END;


Оператор поискового CASE
--------------------------

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2,3,4,5
             
             CASE
             WHEN <лог.выражение_1> THEN <результат_1>;
             [WHEN <лог.выражение_2> THEN <результат_2>;]
             [ELSE <выражение по умолчанию>;]
             END CASE [<<метка>>] ;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2,3,4,5

             CASE
             WHEN <лог.выражение_1> THEN <результат_1>
             [WHEN <лог.выражение_2> THEN <результат_2>]..
             [ELSE <выражение по умолчанию>]
             END


Операторы перехода
-------------------





Оператор EXIT
^^^^^^^^^^^^^^

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1
             :redlines: 2
             
             EXIT [<метка>] 
             [WHEN <булево выражение>] ;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1
             
             EXIT;
                                                  .




Оператор CONTINUE
^^^^^^^^^^^^^^^^^^^

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1
             :redlines: 2
             
             CONTINUE [<метка>] 
             [WHEN <булево выражение>] ;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1
             
             CONTINUE [<метка>];
                                                   .



Вызов процедуры
-------------------




Операция присваивания
-----------------------

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1
             
             <имя переменной> := <выражение>;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1
             
             <имя переменной> = <выражение>;



Оператор EXECUTE IMMEDIATE
----------------------------------

          
.. code-block::
    :redlines: 3,4,5,6,7,8
    :greenlines: 1,2,9
    
    EXECUTE IMMEDIATE '<оператор>'
    [ { INTO { <имя переменной> [, <имя переменной> ]... | <перемення типа RECORD> } 
      | BULK COLLECT INTO { <коллекция>|<:host_array>}
        [, {<коллекция>|<:host_array> } ]... 
      } [USING [IN|OUT|IN OUT] <аргумент привязки> [ [,] [[IN|OUT|IN OUT] <аргумент привязки> ]...]]
    | USING [IN|OUT|IN OUT] <аргумент привязки> [ [,] [[IN|OUT|IN OUT] <аргумент привязки> ]...] 
      [ { RETURNING | RETURN } { INTO ... | BULK COLLECT INTO ... } ]
    | { RETURNING | RETURN } { INTO ... | BULK COLLECT INTO ... } 
    ] ;

                  
.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :greenlines: 1,2
             :redlines: 3
             
             EXECUTE IMMEDIATE '<оператор>'
             [INTO { <имя перем-ой> [, <имя перем-ой>...]
                   | <перемення типа RECORD>}];

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,2
             :redlines: 3
             
             EXECUTE STATEMENT '<оператор>'
             [INTO {[:]<имя перем-ой> [,[:]<имя перем-ой>]
                   | <перемення типа RECORD> } ]


Оператор Pragma AUTONOMOUS_TRANSACTION
----------------------------------------    



.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. color-block::
             
             :green:`PRAGMA AUTONOMOUS_TRANSACTION;`
                                                          .

                  
        - :ess:`Rdb`
        
          .. code-block::
            :greenlines: 1,2
            
            IN AUTONOMOUS TRANSACTION DO
            BEGIN <блок psql операторов> END
          


Работа с курсорами
------------------------

Ниже рассмотрены основные операции для работы с курсорами: :ref:`открытие <subsec:open>`, :ref:`закрытие <subsec:close>`, 
:ref:`извлечение данных <subsec:fetch>`, :ref:`оператор цикла <subsec:forloopcursor>`.
Курсоры в PL/SQL также имеют 4 атрибута, указывающих их состояние и результаты работы: 
``%ROWCOUNT``, ``%FOUND``, ``%ISOPEN``, ``%NOTFOUND``. Их конвертация описана в подразделе :ref:`subsec:attr`.


.. _subsec:open:

Открытие курсора (``OPEN``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Сравнение синтаксиса открытия курсора:

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. color-block::
             
             :green:`OPEN <имя курсора>` :red:`[(<список знач. парам.>)]`:green:`;`

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1
             
             OPEN <имя курсора> ;

:ess:`Замечание:`

- Курсоры с входными параметрами не поддерживаются в РБД и не могут быть сконвертированы.


.. code-block:: sql
    :caption: Oracle
  
    DECLARE
      num testt.num%TYPE;
      cursor c1 is
        SELECT num FROM testt;
    BEGIN
      OPEN c1;
      FETCH c1 into num;
      CLOSE c1;
    END;

.. code-block:: sql
    :caption: to Rdb
  
    EXECUTE BLOCK
    AS 
      DECLARE num TYPE OF COLUMN testt.num;
      DECLARE c1 CURSOR FOR
        (SELECT num FROM testt);
    BEGIN
      OPEN c1;
      FETCH c1 into :num;
      CLOSE c1;
    END;


.. _subsec:close:

Закрытие курсора (``CLOSE``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Сравнение синтаксиса закрытия курсора:

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :redlines: 2,3
             :greenlines: 1
             
             CLOSE { <имя курсора> 
                   | <имя переменной типа REF CURSOR> 
                   | :<host_cursor_variable> } ;

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1
             
             CLOSE <имя курсора>;

             :addline:

:ess:`Замечание:`

- Типы ``REF CURSOR`` не поддерживаются в РБД и не могут быть сконвертированы.

.. _subsec:fetch:

Получение данных из курсора (``FETCH``)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Сравнение синтаксиса получения данных из курсора:

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
          
          .. code-block::
             :redlines: 2,3,6,7
             :greenlines: 1,4,5,8
             
             FETCH { <курсор>
                   | <переменная курсора>
                   | :<host_cursor_variable> }
             { INTO { <переменная> [,<переменная>...]
                    | <переменная типа RECORD>} 
             | BULK COLLECT INTO <список коллекций> 
               [LIMIT <числовое выражение>] 
             };

                  
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1,4,5
             
             FETCH <курсор>


             [INTO { [:]<переменная>[,[:]<переменная>...]
                   | <переменная типа RECORD>}];


             :addline:
             

:ess:`Замечание:`

- Типы ``REF CURSOR`` не поддерживаются в РБД и не могут быть сконвертированы.
- Конструкция ``BULK COLLECT INTO`` удаляется, т.к. РБД не поддерживает типы коллекций



.. _subsec:forloopcursor:

Оператор FOR LOOP для курсора
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Рассмотрим синтаксис оператора цикла ``FOR`` для курсоров:

.. color-block::
    :caption: Oracle
    
    :green:`FOR <имя переменной цикла> IN <имя курсора>` 
      :red:`[(<список значений параметров>)]`
    :green:`LOOP` 
      :green:`<оператор> [<оператор>...]`
    :green:`END LOOP` :red:`[<метка>]` :green:`;`


Оператор цикла ``FOR LOOP`` для курсора автоматически создает переменную цикла типа Record и затем инициирует открытие курсора.

На каждой итерации из набора результатов извлекается строка и помещается в переменную цикла, что означает, что оператор ``FOR`` 
неявно выполняет операцию ``FETCH``. Когда строки для извлечения заканчиваются, курсор закрывается. Кроме того, курсор будет закрыт, 
если управление передается за пределы цикла или происходит вызов исключения внутри него.

Аналогичного оператора цикла для курсоров в РБД нет, поэтому при конвертации выполняются следующие задачи:

1. *Замена цикла* ``FOR`` *на* ``WHILE`` 

   Чтобы имитировать работу цикла ``FOR`` в Oracle, создается цикл ``WHILE`` с условием для контекстной переменной ``ROW_COUNT`` - 
   она не должна быть нулевой. В конце цикла добавляется оператор ``FETCH`` для извлечения следующего набора данных.

   .. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
      
          .. code-block::
            :greenlines: 1, 2, 3, 4, 5
             
            FOR <перем. цикла> IN <имя курсора> 
            LOOP
               <оператор> [<оператор>...] 

            END LOOP;
  	                                                        
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5
             
             WHILE ( ROW_COUNT != 0 ) DO
             BEGIN  
              <оператор> [<оператор>...] 
              FETCH <имя курсора> INTO <пер.цикла>;
             END 

2. *Добавление переменной цикла*
   
   В Oracle данные на каждой итерации извлекаются в переменную цикла (которая создается неявно). 
   Поэтому требуется явно задать переменную цикла с типом данных записей курсора.

   .. code-block:: redstatement
    :caption: Rdb
    :greenlines: 1
  
    DECLARE VARIABLE <имя пер.цикла> TYPE OF TABLE <имя курсора>;

3. *Открытие курсора и извлечение первого значения*

   Перед циклом ``WHILE`` требуется явно открыть курсор (``OPEN``). А также извлечь первую строку из набора данных (``FETCH``).

Таким образом, преобразование конструкции ``FOR`` будет иметь следующий синтаксис:

.. code-block:: 
    :greenlines: 1,2,3,4,5,6,7,8,9, 10, 11
    :caption: to Rdb
    
    DECLARE VARIABLE <имя пер.цикла> TYPE OF TABLE <имя курсора>;
    ...
    OPEN <имя курсора>;
    FETCH <имя курсора> INTO <item>;
    WHILE ( ROW_COUNT != 0 ) DO 
    BEGIN
      <оператор> [<оператор>...] 
      FETCH <имя курсора> INTO <item>;
    END
    CLOSE <имя курсора>;
    ... 

.. code-block:: sql
  :caption: Oracle

  DECLARE
    total_val number(6);
    cursor c1 is
      SELECT * FROM testt WHERE id = 2;
  BEGIN
    total_val := 0;
    FOR i in c1
    LOOP
       total_val := total_val + i.num;
    END LOOP;
  END;


.. code-block:: sql
  :caption: to Rdb

  EXECUTE BLOCK 
  AS 
    DECLARE total_val NUMERIC(6);
    DECLARE c1 CURSOR FOR
      (SELECT * FROM testt WHERE id = 2);
    DECLARE VARIABLE C1_I TYPE OF TABLE C1;
  BEGIN
    total_val = 0; 
    OPEN C1;
    FETCH C1 INTO C1_I;
    WHILE ( ROW_COUNT != 0 ) DO 
    BEGIN
       total_val = :total_val + C1_I.num;
       FETCH C1 INTO C1_I;
    END
    CLOSE C1;
  END;



.. _subsec:attr:

Атрибуты курсора
^^^^^^^^^^^^^^^^^^

%ROWCOUNT
""""""""""""

Атрибут ``%ROWCOUNT`` является числовым атрибутом и возвращает число строк считанных курсором на определенный момент времени. 
В РБД существует контекстная переменная ``ROW_COUNT``,  которая указывает общее количество строк, которые были прочитаны, 
добавлены, изменены или удалены в процессе выполнения предыдущего оператора SQL. 
При конвертации атрибут ``%ROWCOUNT`` заменяется на неё.

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
      
          .. code-block::
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
             
             <имя курсора>%ROWCOUNT
                                                             
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
             
             ROW_COUNT


           


.. code-block:: sql
   :caption: Oracle

   CREATE FUNCTION TEST_ROWCOUNT
   RETURN varchar2
   IS
     v_emp emp%ROWTYPE;
     CURSOR c_emp IS
      SELECT * FROM emp WHERE ename='SMITH';
   BEGIN
     OPEN c_emp;
     FETCH c_emp INTO v_emp;
     IF c_emp%ROWCOUNT=1 THEN
       Return 'found';
     ELSE
       Return 'not found';
     END IF;
     CLOSE c_emp;
   END;


.. code-block:: sql
  :caption: to Rdb

  CREATE FUNCTION TEST_ROWCOUNT
  RETURNS VARCHAR(32765)
  AS
    DECLARE VARIABLE v_emp TYPE OF TABLE emp;
    DECLARE c_emp CURSOR FOR
      (SELECT * FROM emp WHERE ename='SMITH');
  BEGIN
    OPEN c_emp;
    FETCH c_emp INTO :v_emp;
    IF (ROW_COUNT=1) THEN
      Return 'found';
    ELSE
      Return 'not found';   
    CLOSE c_emp;
  END;

%FOUND
""""""""""

Данный атрибут является логическим объектом, он возвращает результат ``TRUE``, если последняя операция выборки успешно 
извлекла запись, в противном случае он вернет ``FALSE``.
В РБД существует контекстная переменная ``ROW_COUNT``,  которая указывает общее количество строк, которые были прочитаны, 
добавлены, изменены или удалены в процессе выполнения предыдущего оператора SQL. 
При конвертации атрибут ``%FOUND`` заменяется на выражение ``ROW_COUNT != 0``.

.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
      
          .. code-block::
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
             
             <имя курсора>%FOUND
                                                             
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
             
             ROW_COUNT != 0


.. code-block:: sql
   :caption: Oracle

   CREATE FUNCTION TEST_ROWCOUNT
   RETURN varchar2
   IS
     v_emp emp%ROWTYPE;
     CURSOR c_emp IS
      SELECT * FROM emp WHERE ename='SMITH';
   BEGIN
     OPEN c_emp;
     FETCH c_emp INTO v_emp;
     IF c_emp%FOUND THEN
       Return 'found';
     ELSE
       Return 'not found';
     END IF;
     CLOSE c_emp;
   END;


.. code-block:: sql
  :caption: to Rdb

  CREATE FUNCTION TEST_ROWCOUNT
  RETURNS VARCHAR(32765)
  AS
    DECLARE VARIABLE v_emp TYPE OF TABLE emp;
    DECLARE c_emp CURSOR FOR
      (SELECT * FROM emp WHERE ename='SMITH');
  BEGIN
    OPEN c_emp;
    FETCH c_emp INTO :v_emp;
    IF (ROW_COUNT != 0) THEN
      Return 'found';
    ELSE
      Return 'not found';   
    CLOSE c_emp;
  END;



%NOTFOUND
""""""""""""

Данный атрибут является логическим объектом, он возвращает результат ``TRUE``, если последняя операция выборки не смогла 
получить какую-либо запись, в противном случае он вернет ``FALSE``.
В РБД существует контекстная переменная ``ROW_COUNT``,  которая указывает общее количество строк, которые были прочитаны, 
добавлены, изменены или удалены в процессе выполнения предыдущего оператора SQL. 
При конвертации атрибут ``%NOTFOUND`` заменяется на выражение ``ROW_COUNT != 1``.


.. list-table::
      :class: borderless
      
      * - :ess:`Oracle`
      
          .. code-block::
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
             
             <имя курсора>%NOTFOUND
                                                             
        - :ess:`Rdb`
        
          .. code-block:: 
             :greenlines: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
             
             ROW_COUNT != 1


.. code-block:: sql
   :caption: Oracle

   CREATE FUNCTION TEST_ROWCOUNT
   RETURN varchar2
   IS
     v_emp emp%ROWTYPE;
     CURSOR c_emp IS
      SELECT * FROM emp WHERE ename='SMITH';
   BEGIN
     OPEN c_emp;
     FETCH c_emp INTO v_emp;
     IF c_emp%NOTFOUND THEN
       Return 'not found';
     ELSE
       Return 'found';
     END IF;
     CLOSE c_emp;
   END;


.. code-block:: sql
  :caption: to Rdb

  CREATE FUNCTION TEST_ROWCOUNT
  RETURNS VARCHAR(32765)
  AS
    DECLARE VARIABLE v_emp TYPE OF TABLE emp;
    DECLARE c_emp CURSOR FOR
      (SELECT * FROM emp WHERE ename='SMITH');
  BEGIN
    OPEN c_emp;
    FETCH c_emp INTO :v_emp;
    IF (ROW_COUNT != 1) THEN
      Return 'not found';
    ELSE
      Return 'found';   
    CLOSE c_emp;
  END;


%ISOPEN
""""""""

Атрибут ``%ISOPEN``, который проверяет открыт ли курсор в данный момент, не может быть сконвертирован.

.. code-block:: 
   :redlines: 1
   :caption: Oracle

   <имя курсора>%ISOPEN


Типы данных
---------------

.. code-block::
    :redlines: 1,2,3,5,8,10,11,13,14,15
    :greenlines: 4,6,7,9,12,16
    
    { <имя типа Varray>
    | <имя типа вложенных таблиц>
    | [REF] <пользовательский тип>
    | <имя типа RECORD>
    | <имя типа REF CURSOR>
    | <тип данных SQL>
    | <имя курсора>%ROWTYPE
    | <переменная курсора>%ROWTYPE
    | <имя таблицы/представления>%ROWTYPE
    | <переменная типа коллекции>%TYPE
    | <переменная курсора>%TYPE
    | <имя таблицы/представления>.<столбец>%TYPE
    | <имя экземпляра ADT>%TYPE
    | <переменная типа RECORD>[.<поле>]%TYPE
    | <скалярная переменная>%TYPE
    }



- :ess:`Имя типа RECORD`
- :ess:`Тип данных SQL`
- :ess:`Имя курсора%ROWTYPE`
- :ess:`Имя таблицы/представления%ROWTYPE`
- :ess:`Имя таблицы/представления.столбец%TYPE`
