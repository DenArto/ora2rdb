## Иерархические запросы

[Статья](https://habr.com/ru/articles/43955/) про иерархические запросы 

[Официальная документация](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)

### START WITH.

Задает условия определения корня дерева.

### CONNECT BY.

Определяет условие связи родительских записей и дочерних.

### NOCYCLE.

Задает режим при котором будут игнорироваться "петли" в дереве. Т.е. ситуации когда родительская запись ссылается на дочернюю, а дочерняя снова на родительскую. С этой опцией у вас не будет переполнения рекурсии. Отследить зацикленные узлы можно с помощью поля CONNECT_BY_IS_CYCLE. Это поле вернет 1 если узел зациклен.

### PRIOR

В условии CONNECT BY должен быть определен оператор PRIOR. Этот оператор задает направление развертывания иерархии. PRIOR указывается со стороны поля которое должно быть дочерним при развертывании. Т.е. таким образом мы указываем уловие "родитель" = "предыдущему потомку". Другими словами рекурсия на каждом новом проходе ищет потомков предыдущей записи, собирая иерархию.


Пример запроса в oracle 

    SELECT level, id, pid, title
    
    FROM test_table
    
    START WITH pid is null
    
    CONNECT BY PRIOR id = pid;

Аналог в РБД 

    WITH RECURSIVE
    
    Rec (id, pid, title)
    
    AS (
    
    SELECT id, pid, title FROM test_table
    
    UNION ALL
    
    SELECT Rec.id, Rec.pid, Rec.title
    
        FROM Rec, test_table
    
        WHERE Rec.id = test_table.pid
    
    )
    
    SELECT * FROM Rec
    
    WHERE pid is null;

### ORDER SIBLINGS BY

Чтобы указать Ораклу, что сортировать надо только в пределах одного уровня иерархии, нам поможет маленькая добавка в виде оператора SIBLINGS.

    TREE
    -----------------------------
    Россия
        Воронеж
            ООО "Рога и копыта"
            Главный офис
            Офис 1
            Офис 2
                Сервер 1
    Лиски
        ЛискиПресс
    Москва

