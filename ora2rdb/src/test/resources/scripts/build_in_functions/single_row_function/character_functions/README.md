--------------------------------

Тестирование встроенных функций для работы со строками.

DUAL — это специальная виртуальная таблица, которая используется для выполнения запросов, когда вам не нужно работать с данными из реальной таблицы, а нужно просто выполнить выражение или вычисление. Эта таблица существует по умолчанию в базе данных Oracle и всегда содержит одну строку и один столбец.

--------------------------------

### ASCII

Используется для возвращения ASCII-кода (числового значения) первого символа строки. Эта функция полезна, если нужно узнать 
числовое представление символа в кодировке ASCII.

Аналог в РБД -- ASCII_VAL

**Совпадает только с символами, которые принадлежат кодировке ASCII (коды от 0 до 127).**

Для многобайтовых наборов символов (таких как символы кириллицы) функция выдаёт десятичный эквивалент шестнадцатеричного значения, которое например равно a1a2 (a1 представляет первый байт, а a2 — второй байт).

Возможно стоит выдавать комментарий что результат может отличаться.

--------------------------------

### CHR

Возвращает символ типа VARCHAR2 (длина 1), соответствующий заданному коду.
Функция является обратной по отношению к функции ASCII. У нее имеется разновидность, удобная при работе с данными в национальных наборах символов:

```
CHR(код USING NCHAR_CS)
```

Возвращает символ типа NVARCHAR2 из национального набора символов.

Аналог в РБД -- ASCII_CHAR. Она может принимать значения от 0 до 255.

**Совпадает только с символами, которые принадлежат кодировке ASCII (коды от 0 до 127).**

В кодировке ASCII символы с кодами от 0 до 127 представляют стандартный набор ASCII (буквы латинского алфавита, цифры, знаки препинания и т. д.). Однако, начиная с кодов от 128 до 255, символы могут варьироваться в зависимости от используемой кодировки.

Для однобайтовых наборов символов, если n > 256, то Oracle Database возвращает двоичный эквивалент n mod 256. 

`USING NCHAR_CS` не конвертируется

Возможно стоит выдавать комментарий, что результат может отличаться.

--------------------------------

### CONCAT

```
  CONCAT(строка1, строка2 [, строка 3 ...])
```

Присоединяет строку2 в конец строки1. Аналогичного результата можно добиться при помощи выражения `строка1 || строка2`.

В РБД такой функции нет, но аналогичного результата можно добиться при помощи выражения `строка1 || строка2` . 

--------------------------------

### INITCAP

Изменяет регистр символов строкового аргумента, переводя первую букву каждого слова строки в верхний регистр, а остальные буквы — в нижний. Словом считается последовательность символов, отделенная от остальных символов пробелом или
символом, не являющимся буквенно-цифровым (например, # или _). 
Например, вызов `INITCAP('this is lower')` дает результат `'This Is Lower'`.

Аналогичной встроенной функции нет, но можно создать подобную.

--------------------------------

### INSTR

```
 INSTR(строка1, строка2)
```
Возвращает позицию, с которой `строка2` входит в `строку1`; если вхождение не обнаружено, функция возвращает 0.
Существует несколько разновидностей этой функции:

- `INSTR(строка1, строка2, начальная_позиция)`

Поиск строки2 в строке1 начинается с позиции, заданной последним параметром.
По умолчанию поиск начинается с позиции 1, так что вызов INSTR(string1,string2, 1) эквивалентен вызову INSTR(string1, string2).

- `INSTR(строка1, строка2, отрицательная_начальная_позиция)`

Смещение начальной позиции задается не от начала, а от конца `строки1`.

- `INSTR(строка1, строка2, начальная_позиция, n)`

Находит n-е вхождение строки2, начиная с заданной начальной позиции.

- `INSTR(строка1, строка2, отрицательная_начальная_позиция, n)`

Находит n-е вхождение `строки2`, начиная с заданной начальной позиции от конца `строки1`.

Аналогичная функция в РБД:

```sql
  POSITION(<строка 2>, <строка 1>  [, <начальная позиция> [, <номер вхождения подстроки>] ] )
```

Но здесь <начальная позиция> не может быть меньше нуля, поэтому функцию стоит переопределить.

Функция `INSTR` рассматривает строку как последовательность символов. Ее разновидности `INSTRB`, `INSTR2` и `INSTR4` рассматривают строку как последовательность байтов, кодовых единиц (code units) или кодовых индексов (code points) Юникода соответственно. 

`INSTRB, INSTRC, INSTR2, INSTR4` не конвертируются.

--------------------------------

### LENGTH

```sql
  LENGTH(<строка>)
```

Возвращает количество символов в строке. Разновидности LENGTHB, LENGTH2 и LENGTH4 возвращают количество байтов, кодовых единиц (code units) или кодовых индексов (code points) Юникода соответственно. Разновидность LENGTHC возвращает количество полных символов Юникода, нормализованных по мере возможности (то есть с преобразованием 'a\0303' в '\00E3').

Функция LENGTH обычно не возвращает нуль. Вспомните, что Oracle рассматривает пустую строку ('') как NULL, поэтому вызов LENGTH('') фактически эквивалентен попытке получить длину NULL; ее результат тоже будет равен NULL. Единственное исключение встречается при применении LENGTH к типу CLOB. Тип CLOB может содержать 0 байт и при этом быть отличным от NULL. В этом единственном случае LENGTH возвращает 0.

Эквивалентная функция для `LENGTH`  -- `CHAR_LENGTH`.
Эквивалентная функция для `LENGTHB` -- `OCTET_LENGTH`.

`LENGTHC, LENGTH2, LENGTH4` не конвертируются

**Отличия в пустой строке. Если в оракле задать пустую строку, то результатом будет NULL, а у нас - 0**

--------------------------------

### LOWER

```sql
  LOWER(<строка>)
```

Преобразует все буквы заданной строки в нижний регистр. Функция является обратной по отношению к UPPER. Тип возвращаемого значения соответствует типу входных данных (CHAR, VARCHAR2, CLOB). 

В РБД аналогичная функция.

**Отличия в пустой строке. Если в оракле задать пустую строку, то результатом будет NULL, а у нас - пустая строка.**

```sql
   DECODE(<строка>||'R', 'R', NULL, LOWER(<строка>)) 
```

--------------------------------

### LPAD

```sql
  LPAD(строка1, итоговая_длина)
```

Возвращает значение `строки1`, дополненное слева пробелами до `итоговой_длины`.

У функции существует следующая разновидность:

```sql
  LPAD(строка1, итоговая_длина, заполнитель)
```

Присоединяет достаточное количество полных или частичных вхождений `заполнителя`, чтобы общая длина строки достигла заданной `итоговой_длины`.
К строке, заданной параметром строка 1, в самое начало добавляется строка, заданная заполнителем, в том случае, если числовой параметр больше размера исходной строки.  Если значение числового параметра не превышает размера исходной строки (<строка 1>), то возвращаются первые заданные символы исходной строки.

Похожая функция есть в РБД:

```sql
  LPAD(строка1, итоговая_длина [, заполнитель])
```

Есть отличия:

- Если в оракле заполнитель - пустая строка, возвращается NULL, а у нас - исходная строка (целая или урезанная). 
- Если в оракле итоговая_длина <= 0 , то возвращается NULL, а у нас если 0 то пустая строка, если отрицательное, то ошибка.

--------------------------------

### LTRIM

```sql
   LTRIM(строка1 [, удаляемый_набор])
```

`LTRIM` удаляет с левого конца `строки1` все символы, содержащиеся в `удаляемом_наборе`. Если `удаляемый_набор` не указан, то по умолчанию используется один пробел. Oracle начинает сканирование `строку1` с его первого символа и удаляет все символы, которые появляются в `удаляемом_наборе`, пока не достигнет символа, не входящего в `удаляемый_набор`, а затем возвращает результат.

Похожая функция есть в РБД:

```sql
   TRIM ( LEADING {' ' | <набор символов>} FROM <строка1> ) 
```

Функции работают по разному, потому что <набор символов> рассматривается как фиксированная последовательность символов, которые следуют друг за другом, а удаляемый_набор - это набор, в котором последовательность не важна.

Поэтому функцию требуется конвертировать.

--------------------------------

### NCHR

```sql
  NCHR(код)
```

Возвращает символ типа NVARCHAR2 (длина 1), соответствующий заданному коду. 
Функция CHR с условием USING NCHAR_CS реализует ту же функциональность, что и NCHR .

Не конвертируется.

--------------------------------

### NLS_INITCAP

```sql
  NLS_INITCAP(char [, 'NLS_SORT = sort'])
```

Возвращает строку char, которая должна относиться к типу NVARCHAR2 или NCHAR, в которой первая буква каждого слова переводится в верхний регистр, а остальные буквы — в нижний. sort представляет собой одно из допусти­мых названий правил сортировки.

Не конвертируется.

--------------------------------

### NLS_LOWER

```sql
  NLS_LOWER(char [, 'NLS_SORT = sort'])
```

Возвращает строку char, преобразованную в нижний регистр по правилам заданного языка.

Не конвертируется.

--------------------------------

### NLS_UPPER

```sql
  NLS_UPPER(char [, 'NLS_SORT = sort'])
```

Возвращает строку char, преобразованную в верхний регистр по правилам заданного языка.

Не конвертируется.

--------------------------------

### NLSSORT

```sql
  NLSSORT(char [, 'NLS_SORT = sort'])
```

Возвращает строку байтов, которая может использоваться для сортировки строкового значения по правилам заданного языка. Строка возвращается в формате RAW.

Не конвертируется.

--------------------------------

### REGEXP_COUNT

Функция возвращает целое число, указывающее количество вхождений шаблона. Если совпадений не найдено, функция возвращает 0. Синтаксис:

```sql
  REGEXP_COUNT(целевая_строка, выражение
              [, позиция
              [, параметры_совпадения]])
```

- `целевая_строка` — строка, в которой производится поиск совпадения.
- `выражение` — регулярное выражение, описывающее искомый текст.
- `позиция` — позиция символа в целевой строке, с которой начинается поиск. По умолчанию равна 1.
- `параметры_совпадения` — текстовая строка с параметрами, управляющими процессом поиска совпадений:
   
   - c — поиск с учетом регистра символов (по умолчанию определяется значением NLS_SORT).
   - i — поиск без учета регистра символов.
   - n — разрешает совпадение точки с символами новой строки. По умолчанию точка не совпадает с новой строкой.
   - m — изменяет определение строки в контексте метасимволов ^ и $. По умолчанию под строкой понимается вся целевая строка. С параметром m под строкой понимается каждая из логических строк, ограниченных символами новой строки.

   Вы можете указать несколько параметров совпадения в произвольном порядке. Например, строка «in» означает то же, что «ni». Если задать конфликтующие параметры (например, «ic»), будет использован последний параметр («c» в данном случае).

Подобной функции в РБД нет.

--------------------------------

### REGEXP_INSTR

Возвращает позицию совпадения регулярного выражения в целевой строке. Синтаксис:

```sql
REGEXP_INSTR(целевая_строка, выражение
             [, позиция [, вхождение
             [, режим_возврата
             [, параметры_совпадения
             [, подвыражение]]]]])
```

- `целевая_строка` — строка, в которой производится поиск совпадения.
- `выражение` — регулярное выражение, описывающее искомый текст.
- `позиция` — позиция символа в целевой строке, с которой начинается поиск. По умолчанию равна 1.
- `вхождение` — номер вхождения искомого совпадения. По умолчанию равен 1 (поиск первого возможного совпадения).
- `режим_возврата` — используется только для REGEXP_INSTR; определяет, позиция какого символа должна возвращаться для совпадения. По умолчанию используется значение 0 (начало). Используйте значение 1, чтобы возвращать конечную позицию.
- `параметры_совпадения` — текстовая строка с параметрами, управляющими процессом поиска совпадений:
   
   - c — поиск с учетом регистра символов (по умолчанию определяется значением NLS_SORT).
   - i — поиск без учета регистра символов.
   - n — разрешает совпадение точки с символами новой строки. По умолчанию точка не совпадает с новой строкой.
   - m — изменяет определение строки в контексте метасимволов ^ и $. По умолчанию под строкой понимается вся целевая строка. С параметром m под строкой понимается каждая из логических строк, ограниченных символами новой строки.

   Вы можете указать несколько параметров совпадения в произвольном порядке. Например, строка «in» означает то же, что «ni». Если задать конфликтующие параметры (например, «ic»), будет использован последний параметр («c» в данном случае).
- `подвыражение` — цифра (0­–9), идентифицирующая подвыражение. По умолчанию используется значение 0, означающее, что подвыражения не используются.

Подобной функции в РБД нет.


--------------------------------

### REGEXP_REPLACE

Выполняет операцию поиска и замены.
Синтаксис:

```sql
  REGEXP_REPLACE(целевая_строка, выражение
                 [, строка_замены
                 [, позиция [, вхождение
                 [, параметры_совпадения]]]])
```

- `целевая_строка` — строка, в которой производится поиск совпадения.
- `выражение` — регулярное выражение, описывающее искомый текст.
- `строка_замены` — строка, генерирующая текст, который должен использоваться в операции поиска с заменой.
- `позиция` — позиция символа в целевой строке, с которой начинается поиск. По умолчанию равна 1.
- `вхождение` — номер вхождения искомого совпадения. По умолчанию равен 1 (поиск первого возможного совпадения).
- `параметры_совпадения` — текстовая строка с параметрами, управляющими процессом поиска совпадений:
   
   - c — поиск с учетом регистра символов (по умолчанию определяется значением NLS_SORT).
   - i — поиск без учета регистра символов.
   - n — разрешает совпадение точки с символами новой строки. По умолчанию точка не совпадает с новой строкой.
   - m — изменяет определение строки в контексте метасимволов ^ и $. По умолчанию под строкой понимается вся целевая строка. С параметром m под строкой понимается каждая из логических строк, ограниченных символами новой строки.

   Вы можете указать несколько параметров совпадения в произвольном порядке. Например, строка «in» означает то же, что «ni». Если задать конфликтующие параметры (например, «ic»), будет использован последний параметр («c» в данном случае).

Подобной функции в РБД нет.


--------------------------------

### REGEXP_SUBSTR

Извлекает текст, совпадающий с регулярным выражением в строке. Синтаксис:

```sql
  REGEXP_SUBSTR(целевая_строка, выражение
                [, позиция [, вхождение
                [, параметры_совпадения
                [, подвыражение]]]] )
```

- `целевая_строка` — строка, в которой производится поиск совпадения.
- `выражение` — регулярное выражение, описывающее искомый текст.
- `позиция` — позиция символа в целевой строке, с которой начинается поиск. По умолчанию равна 1.
- `вхождение` — номер вхождения искомого совпадения. По умолчанию равен 1 (поиск первого возможного совпадения).
- `параметры_совпадения` — текстовая строка с параметрами, управляющими процессом поиска совпадений:
   
   - c — поиск с учетом регистра символов (по умолчанию определяется значением NLS_SORT).
   - i — поиск без учета регистра символов.
   - n — разрешает совпадение точки с символами новой строки. По умолчанию точка не совпадает с новой строкой.
   - m — изменяет определение строки в контексте метасимволов ^ и $. По умолчанию под строкой понимается вся целевая строка. С параметром m под строкой понимается каждая из логических строк, ограниченных символами новой строки.

   Вы можете указать несколько параметров совпадения в произвольном порядке. Например, строка «in» означает то же, что «ni». Если задать конфликтующие параметры (например, «ic»), будет использован последний параметр («c» в данном случае).

- `подвыражение` — цифра (0­–9), идентифицирующая подвыражение. По умолчанию используется значение 0, означающее, что подвыражения не используются.

В РБД существует аналогичная функция:

```sql
REGEXP_SUBSTR(<исходная строка>, <шаблон>[,<номер группы>, <номер вхождения>, <параметр сравнения>, <позиция>])
```

- <исходная строка> — строка для поиска в ней нужной подстроки.
- <шаблон> — регулярное выражение для поиска подстроки. О синтаксисе регулярного выражения будет рассказано далее.
- <позиция> - это порядковый номер символа исходной строки, с которого начнется поиск. По умолчанию 1, т.е. поиск с начала строки.
- <номер вхождения> — это положительно целое число показывает какое по счету вхождение подстроки (удовлетворяющей шаблону) в исходной строке нужно искать. Если этот параметр не задан или его значение меньше 1, он считается равным 1. При этом в качестве результата работы функции используется первая найденная подстрока.

Если данный параметр больше 1, то ищутся следующие вхождения подстроки в исходную строку. Для этого на N-м этапе запускается поиск подстроки начиная с позиции M+1 исходной строки, где M – конец подстроки, найденной на этапе N-1. Если на одном из этапов подстрока не найдена, возвращается NULL.

- <параметр сравнения> позволяет изменять поведение функции. Можно указать одно или более значений данного параметра, представленных в таблице:

  - I -- Нечувствительность к регистру. По умолчанию поиск чувствителен к регистру. Для корректной работы этого режима входная строка должна иметь правильно указанную кодировку и COLLATE, иначе ядро СУБД не сможет соотносить символы верхнего/нижнего регистра.
  - G -- Включение "ленивого" (non-greedy) режима сопоставления. По умолчанию используется "жадный" режим, даже если используются квантификаторы +?, *?, ?? и {n,}?.
  - M -- Режим множества строк (multi-line). Символы шаблона ^ и $ становятся спецсимволами, соответствующими началу и концу строки. Без этого режима символы ^ и $ не являются специальными (кроме использования ^ внутри [ ]).
  - X -- Режим игнорирования пробельных символов (free-spacing). Все пробельные символы игнорируются в шаблоне. Чтобы при этом указать в шаблоне пробел, нужно его экранировать "", либо указать в квадратных скобках [ ]. Кроме того, в этом режиме символ решётки # начинает однострочный комментарий - игнорируется он сам и все символы после него до конца строки или регулярного выражения.
  - S -- Режим единственной строки (single-line). Символ '.' будет соответствовать всем символам, в том числе переносу строки.
  - T -- Обрезание пробелов справа в исходной строке и регулярном выражении. Необходим в случае передачи в функцию входных значений через механизм параметров в EXECUTE STATEMENT, так как в таком случае типы данных не сохраняются и значения дополняются пробелами справа.

При конвертации нужно поменять местами параметры последний и третий. Если указан третий ,а последний нет, то в РБД придется дописывать все остальные параметры. Значения по умолчанию: <номер группы> = 0, <номер вхождения> = 1, <параметр сравнения> = ''

Замена параметров сравнения:
- 'c' заменяется на пустую строку ''
- 'i' остается
- 'n' заменяется на 'S'
- 'm' остается

Результаты регулярных выражений как и сам синтаксис регулярных выражений может отличаться. 
Номер вхождения отличается, потому что функции ищут результаты по разному - см пример 5. В РБД регулярное выражение проверяется с начала строки и далее следующее вхождение ищется со второго символа, с третьего и т.д. А в Оракле если найдена подстрока то следующее вхождение ищется начиная с символа после первой подстроки и т.д.

В РБД не используются квантификаторы +?, *?, ?? и {n,}?. Вместо них включается ленивый режим "G".

Возможно при конвертации стоит комментировать эту функцию, но если не комментировать то оставлять комментарий, что следует перепроверить регулярное выражение, потому что результат может отличаться. 

--------------------------------

### REPLACE

```sql
  REPLACE(строка1, искомая_строка [, замена])
```

Возвращает строку, полученную в результате замены всех вхождений `искомой_строки` в `строке1` строкой `замена`. Функция `REPLACE` может использоваться для замены всех вхождений определенной подстроки в одной инструкции.

Если `замена` опущено или равно null, то все вхождения `искомой_строки` удаляются. Если `искомая_строка` равно null, то возвращается `строка1`.

В РБД есть аналогичная функция: 

```sql
  REPLACE(<исходная строка>, <отыскиваемая подстрока>, <строка замены>)
```

Функция выполняет замену в исходной строке всех найденных подстрок (отыскиваемая подстрока) на заданную третьим параметром строку замены.

Если отыскиваемая подстрока является пустой строкой, то возвращается исходная строка без изменений. Если заменяемая строка является пустой строкой, то все вхождения отыскиваемой подстроки удаляются из исходной.
Если любой из аргументов равен `NULL`, то результатом всегда будет `NULL`, даже если не было произведено ни одной замены

Поэтому функцию можно конвертировать так:

```sql
  REPLACE(NULLIF(<исходная строка>, ''), COALESCE(<отыскиваемая подстрока>, ''), COALESCE(<строка замены>, ''))
```

--------------------------------

### RPAD

```sql
  RPAD(строка1, итоговая_длина)
```

Возвращает значение `строки1`, дополненное справа пробелами до `итоговой_длины`.

У функции существует следующая разновидность:

```sql
  RPAD(строка1, итоговая_длина, заполнитель)
```

Присоединяет справа достаточное количество полных или частичных вхождений `заполнителя`, чтобы общая длина строки достигла заданной `итоговой_длины`.
К строке, заданной параметром строка 1, в конец добавляется строка, заданная заполнителем, в том случае, если числовой параметр больше размера исходной строки. Если значение числового параметра не превышает размера исходной строки (<строка 1>), то возвращаются первые заданные символы исходной строки.

Похожая функция есть в РБД:

```sql
  RPAD(строка1, итоговая_длина [, заполнитель])
```

Есть отличия:

- Если в оракле заполнитель - пустая строка, возвращается NULL, а у нас - исходная строка (целая или урезанная). 
- Если в оракле итоговая_длина <= 0 , то возвращается NULL, а у нас если 0 то пустая строка, если отрицательное, то ошибка.

--------------------------------

### RTRIM

```sql
   RTRIM(строка1 [, удаляемый_набор])
```

`RTRIM` удаляет с правого конца `строки1` все символы, содержащиеся в `удаляемом_наборе`. Если `удаляемый_набор` не указан, то по умолчанию используется один пробел. Oracle начинает сканирование `строку1` с его первого символа и удаляет все символы, которые появляются в `удаляемом_наборе`, пока не достигнет символа, не входящего в `удаляемый_набор`, а затем возвращает результат.

Похожая функция есть в РБД:

```sql
   TRIM ( TRAILING {' ' | <набор символов>} FROM <строка1> ) 
```

Функции работают по разному, потому что <набор символов> рассматривается как фиксированная последовательность символов, которые следуют друг за другом, а удаляемый_набор - это набор, в котором последовательность не важна.

Поэтому функцию требуется конвертировать.

--------------------------------

### SOUNDEX

Функция SOUNDEX в Oracle используется для сравнения строк по их звучанию, а не по точному совпадению символов. Это особенно полезно при поиске строк, которые могут быть написаны разными способами, но звучат одинаково.

Когда вызывается функция SOUNDEX, она преобразует строку в код, который отражает звучание этой строки. Затем этот код можно использовать для сравнения строк, даже если они написаны немного по-разному, но звучат похоже.

```sql
   SOUNDEX( <строка1> ) 
```

Функция SOUNDEX работает следующим образом:

- Каждое слово в строке преобразуется в уникальный код, который представляет его звучание.
- Этот код состоит из первой буквы слова, за которой следуют цифры, отражающие звуки, похожие на исходные буквы.

Например:

    `SOUNDEX('Smith')` и `SOUNDEX('Smythe')` могут вернуть одинаковый результат, поскольку эти фамилии звучат схоже.

Использование SOUNDEX помогает в поиске строк с похожим звучанием, что полезно при обработке данных, например, для поиска опечаток или схожих имен.

Алгоритм SOUNDEX ориентирован на английский язык; в других языках он может работать плохо (или не работать вообще).

В РБД аналога нет.

--------------------------------

### SUBSTR

```sql
   SUBSTR( строка1, начальная_позиция [, длина])
```

Возвращает подстроку из `строки1`, которая начинается с начальной_позиции и имеет заданную длину. Если количество символов до конца строки1 окажется меньше длины, возвращаются все символы от начальной позиции до конца строки. 

У функции существуют следующие разновидности:

```sql
   SUBSTR( строка1, начальная_позиция)
```

Возвращает все символы от `начальной_позиции` до конца `строки1`.

```sql
   SUBSTR( строка1, отрицательная_начальная_позиция, длина)
```

Начальная позиция подстроки отсчитывается от конца `строки1`.

```sql
    SUBSTR( строка1, отрицательная_начальная_позиция)
```

Возвращает последние ABS(отрицательная_начальная_позиция) строки.

Похожая функция в РБД:

```sql
   SUBSTRING ( <строка> FROM <начальная позиция> [FOR <длина подстроки>])
```

Функция `SUBSTR` рассматривает строку как последовательность символов. Ее разновидности `SUBSTRB`, `SUBSTR2` и `SUBSTR4` рассматривают строку как последовательность байтов, кодовых единиц (code units) или кодовых индексов (code points) Юникода соответственно. 

--------------------------------

### TRIM

```sql
   TRIM( [[ LEADING | TRAILING | BOTH ][ <удаляемый символ> ] FROM] <строка1>)
 ```

`TRIM(<строка1>)` возвращает строку, полученную в результате удаления из строки1 всех начальных и конечных пробелов. У функции существуют следующие разновидности:

- `TRIM(LEADING FROM ...)` -- Удаление только начальных пробелов.
- `TRIM(TRAILING FROM ...)` -- Удаление только конечных пробелов.
- `TRIM(BOTH FROM ...)` -- Удаление как начальных, так и конечных пробелов (используется по умолчанию).
- `TRIM(...удаляемый_символ FROM строка1)` -- Удаление вхождений одного удаляемого_символа .

Она сочетает в себе функциональность `LTRIM` и `RTRIM`, но отличается от них тем, что `TRIM` позволяет задать только один удаляемый символ,
тогда как при использовании `LTRIM` и `RTRIM` можно задать набор удаляемых символов.

Похожая функция есть в РБД:

```sql
   TRIM( [[ LEADING | TRAILING | BOTH ][ <удаляемый символ> ] FROM] <строка1>)
```

--------------------------------

### TRANSLATE

```sql
  TRANSLATE(строка1, искомый_набор, набор_замены)
```

Заменяет в `строке1` каждое вхождение символа из `искомого_набора` соответствующим символом `набора_замены`. Пример:

```sql
  TRANSLATE ('abcd', 'ab', '12') --> '12cd'
```

Если `искомый_набор` содержит больше символов, чем набор_замены, «лишние» символы, не имеющие соответствия в наборе_замены, не включаются в результат. Пример:

```sql
  TRANSLATE ('abcdefg', 'abcd', 'zyx') --> 'zyxefg'
```

Подобной функции в РБД нет. Можно придумать конвертацию.

--------------------------------

### TRANSLATE_USING

```
   TRANSLATE(текст USING CHAR_CS)
```

и 

```
   TRANSLATE(текст USING NCHAR_CS)
```

Преобразует символьные данные в набор символов базы данных (CHAR_CS) или в национальный набор символов (NCHAR_CS). Выходным типом данных будет VARCHAR2 или NVARCHAR2 в зависимости от того, выполняется ли преобразование к набору символов базы данных или национальному набору символов соответственно.

Аналогичной функции нет. Конвертация не придумана.

--------------------------------

### UPPER

```sql
  UPPER(<строка>)
```

Преобразует все буквы заданной строки в верхний регистр. Функция является обратной по отношению к LOWER. Тип возвращаемого значения соответствует типу входных данных (CHAR, VARCHAR2, CLOB). 

В РБД аналогичная функция.

**Отличия в пустой строке. Если в оракле задать пустую строку, то результатом будет NULL, а у нас - пустая строка.**

Возможное конертирование:

```sql
   DECODE(<строка>||'R', 'R', NULL, UPPER(<строка>)) 
```

--------------------------------