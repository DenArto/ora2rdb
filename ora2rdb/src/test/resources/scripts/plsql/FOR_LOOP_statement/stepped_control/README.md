--------------------------------

Тестирование оператора `FOR` для диапазона значений провоизводится для следующих типов PL/SQL объектов:

* Процедура
* Функция
* Пакет (подпроцедура и подфункция)
* Триггер DML
* Анонимный блок

В Oracle/PLSQL цикл `FOR LOOP` позволяет выполнить код повторно в течение фиксированного
количества раз. Переменная цикла (итератор) создается автоматически и принимает значения от <нижней границы> до <верхней границы>.

```sql
  [<< <метка> >>]
  FOR <имя итератора> [MUTABLE | IMMUTABLE] [<тип данных итератора>]
  IN <нижняя граница> .. <верхняя граница> [BY <шаг>]
  [WHILE <условие_остановки>] [WHEN <условие_пропуска>]
  LOOP
     <группа_операторов>
  END LOOP [<метка>];
```

В РБД подобного оператора не существует, но его можно заменить на оператор `WHILE-DO`:

```sql
  DECLARE <имя итератора> {INTEGER|[<тип данных итератора>]};
  DECLARE <вычисленная граница> {INTEGER|[<тип данных итератора>]};
  ...
  <имя итератора> = <нижняя граница>;
  <вычисленная граница> = <верхняя граница>;              -- граница должна вычисляться перед циклом, потому что     
  [<метка>:]                                              -- она может содержать выражение с переменными, которые 
  WHILE (<имя итератора> <= <вычисленная граница>) DO     -- изменяются в цикле.
  BEGIN
    [ IF (NOT (<условие_остановки>) ) THEN LEAVE; ]             -- вместо условия while
    [ IF (NOT (<условие_пропуска>)) THEN                        -- вместо условия when
      BEGIN 
        <имя итератора> = <имя итератора> + {1|<шаг>}; 
        CONTINUE;
      END
    ]
    <группа_операторов>
    <имя итератора> = <имя итератора> + {1|<шаг>};        
  END      
  <имя итератора> = <вычисленная граница>;               -- потому что итератор мб увеличенный на шаг. 
                                                         -- Нужно для возможного следующего вычисления цикла FOR.
```

Чтобы `<имя итератора>` и `<вычисленная верхняя граница>` не пересекалось с именами других итераторов(границ) или с именем локальной переменной, в имя лучше добавить суффикс (причем со счетчиком, потому что мб несколько операторов FOR). В тестах этот суффикс будет "_for1", "_for2" и т.д.
Так как границы могут быть не просто числами, а выражениями (в том числе с содержанием самого индекса), то их обязательно надо вычислять перед циклом.

--------------------------------

### explicit_index_type.sql

Тип индекса указан явно. По умолчанию индекс имеет тип `PLS_INTEGER`.

--------------------------------

### expression_bounds.sql

В качестве верхней и нижней границы указаны не числа а выражения (в том числе с содержанием самого индекса). Эти выражения вычисляются перед FOR, поэтому и при конвертации их обязательно надо вычислять перед циклом.

--------------------------------

### few_fors.sql

Рассматривается два цикла for идущих друг за другом с одним и тем же именем итератора. 

--------------------------------

### for_with_immutable_clause.sql

Для итеранда существуют свойства `MUTABLE` или `IMMUTABLE`. По умолчанию у итеранда состояние `IMMUTABLE` (за исключением цикла по курсорам), что означает, что внутри цикла нельзя менять значение самого итеранда. Иначе возникнет ошибка:
```
PLS-00363: выражение 'I' не м.б. использовано как адресат назначения
```
Это свойство надо закомментировать.

--------------------------------

### for_with_label.sql

Метка перед циклом `FOR`. В РДБ тоже есть подобные метки.

--------------------------------

### for_with_mutable_clause.sql

Для итеранда существуют свойства `MUTABLE` или `IMMUTABLE`. По умолчанию у итеранда состояние `IMMUTABLE` (за исключением цикла по курсорам), что означает, что внутри цикла нельзя менять значение самого итеранда. Иначе возникнет ошибка:

```
PLS-00363: выражение 'I' не м.б. использовано как адресат назначения
```

Если поставить предложение `MUTABLE`, то ошибки не возникает, даже если меняется значение итератора.

Это свойство надо закомментировать.

--------------------------------

### for_with_step_clause.sql

Задан шаг индекса (по умолчанию 1).

--------------------------------

### for_with_when_skip_clause.sql

Задано условие пропуска цикла -- `WHEN`. Если условие не верно, то FOR переходит к следующей итерации. Это условие проверяется в начале каждой итерации.

--------------------------------

### for_with_while_and_when_clause.sql

Заданы оба условия -- `WHILE` и `WHEN`

--------------------------------

### for_with_while_stop_clause.sql

Задано условие выхода из цикла -- `WHILE`. Если условие не верно, то происходит выход из цикла FOR. Это условие проверяется в начале каждой итерации.

--------------------------------

### index_with_label.sql

Можно обратиться к индексу, указав перед ним метку цикла.

--------------------------------

### index_with_same_name_as_variable.sql

Объявлена переменная с таким же именем как и итератор.

--------------------------------

### nested_fors.sql

Вложенный один в другой `FOR`

--------------------------------

### primitive.sql

Рассматривается самый простой случай оператора, где индекс проходит по целым числам.

--------------------------------