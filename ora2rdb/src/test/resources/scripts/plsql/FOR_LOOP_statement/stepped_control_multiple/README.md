--------------------------------

Тестирование оператора `FOR` для диапазона значений провоизводится для следующих типов PL/SQL объектов:

* Процедура
* Функция
* Пакет (подпроцедура и подфункция)
* Триггер DML
* Анонимный блок

В Oracle/PLSQL цикл `FOR LOOP` может содержать цепочку диапазонов значений для итератора. Например

```sql
  [<< <метка> >>]
  FOR <имя итератора> [MUTABLE | IMMUTABLE] [<тип данных итератора>]
  IN [REVERSE] <нижняя граница1> .. <верхняя граница1> [BY <шаг>]
     [WHILE <условие_остановки>] [WHEN <условие_пропуска>] , 
     [REVERSE] <нижняя граница2> .. <верхняя граница2> [BY <шаг>]
     [WHILE <условие_остановки>] [WHEN <условие_пропуска>] 
     [, ... ] 
  LOOP
     <группа_операторов>
  END LOOP [<метка>];
```

В РБД подобного оператора не существует, но его можно заменить на оператор `WHILE-DO`:

```sql
  DECLARE <имя итератора> {INTEGER|[<тип данных итератора>]};
  DECLARE <вычисленная граница> {INTEGER|[<тип данных итератора>]};
  ...
  <имя итератора> = ... ;
  <вычисленная граница> = ... ;
  [<метка>:]
  WHILE (...) DO
  BEGIN
    ...     
    <группа_операторов>
    ...
  END
  <имя итератора> = <вычисленная граница>;
  <вычисленная граница> = ... ;                 -- сначала вычислить границу а потом итератор, потому что выражение может зависеть от итератора
  <имя итератора> = ... ;  
  [<метка>:]
  WHILE (...) DO
  BEGIN
    ...     
    <группа_операторов>
    ...
  END
  <имя итератора> = <вычисленная граница>;
  ...
```

Чтобы `<имя итератора>` и `<вычисленная нижняя граница>` не пересекалось с именами других итераторов(границ) или с именем локальной переменной, в имя лучше добавить суффикс (причем со счетчиком, потому что мб несколько операторов FOR). В тестах этот суффикс будет "_for1", "_for2" и т.д.
Так как границы могут быть не просто числами, а выражениями (в том числе с содержанием самого индекса), то их обязательно надо вычислять перед циклом.
--------------------------------

### explicit_index_type.sql

Тип индекса указан явно. По умолчанию индекс имеет тип `PLS_INTEGER`.

--------------------------------

### expression_bounds.sql

В качестве верхней и нижней границы указаны не числа а выражения (в том числе с содержанием самого индекса). Эти выражения вычисляются перед FOR, поэтому и при конвертации их обязательно надо вычислять перед циклом.

--------------------------------

### for_with_step_clause.sql

Задан шаг индекса (по умолчанию 1).

--------------------------------

### for_with_when_skip_clause.sql

Задано условие пропуска цикла -- `WHEN`. Если условие не верно, то FOR переходит к следующей итерации. Это условие проверяется в начале каждой итерации.

--------------------------------

### for_with_while_and_when_clause.sql

Заданы оба условия -- `WHILE` и `WHEN`

--------------------------------

### for_with_while_stop_clause.sql

Задано условие выхода из цикла -- `WHILE`. Если условие не верно, то происходит выход из цикла FOR. Это условие проверяется в начале каждой итерации.

--------------------------------

### index_with_label.sql

Можно обратиться к индексу, указав перед ним метку цикла.

--------------------------------

### nested_fors.sql

Вложенный один в другой `FOR`

--------------------------------

### primitive.sql

Рассматривается самый простой случай оператора, где индекс проходит по целым числам.

--------------------------------